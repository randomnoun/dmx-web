package com.randomnoun.dmx.web.action;


import gnu.io.RXTXCommDriver;
import gnu.io.RXTXVersion;

import java.awt.Color;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.lang.reflect.Constructor;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;

import javax.script.ScriptException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.log4j.Logger;
import org.apache.struts.action.Action;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;

import com.randomnoun.common.ExceptionUtils;
import com.randomnoun.common.StreamUtils;
import com.randomnoun.common.Struct;
import com.randomnoun.common.Text;
import com.randomnoun.common.security.User;
import com.randomnoun.common.timer.Benchmark;
import com.randomnoun.common.webapp.upload.MonitoredOutputStream;
import com.randomnoun.common.webapp.upload.OutputStreamListener;
import com.randomnoun.dmx.Controller;
import com.randomnoun.dmx.ExceptionContainer;
import com.randomnoun.dmx.Universe;
import com.randomnoun.dmx.audioController.AudioController;
import com.randomnoun.dmx.audioSource.AudioSource;
import com.randomnoun.dmx.channel.ChannelDef;
import com.randomnoun.dmx.channelMuxer.ChannelMuxer;
import com.randomnoun.dmx.config.AppConfig;
import com.randomnoun.dmx.config.AppConfigException;
import com.randomnoun.dmx.config.AppConfig.TimestampedShowException;
import com.randomnoun.dmx.dao.ShowDAO;
import com.randomnoun.dmx.dao.ShowDefDAO;
import com.randomnoun.dmx.fixture.CustomControl;
import com.randomnoun.dmx.fixture.Fixture;
import com.randomnoun.dmx.fixture.FixtureController;
import com.randomnoun.dmx.fixture.FixtureDef;
import com.randomnoun.dmx.fixture.FixtureOutput;
import com.randomnoun.dmx.show.Show;
import com.randomnoun.dmx.show.editor.Command;
import com.randomnoun.dmx.show.editor.DmxValueCommand;
import com.randomnoun.dmx.show.editor.FixtureBlackoutCommand;
import com.randomnoun.dmx.show.editor.FixtureColorCommand;
import com.randomnoun.dmx.show.editor.FixtureCustomControlCommand;
import com.randomnoun.dmx.show.editor.FixtureDimCommand;
import com.randomnoun.dmx.show.editor.FixturePanTiltCommand;
import com.randomnoun.dmx.show.editor.FixtureStrobeCommand;
import com.randomnoun.dmx.show.editor.Frame;
import com.randomnoun.dmx.show.editor.RecordedShow;
import com.randomnoun.dmx.show.editor.Recording;
import com.randomnoun.dmx.stage.Stage;
import com.randomnoun.dmx.to.ShowDefTO;
import com.randomnoun.dmx.to.ShowTO;

/**
 * Fancy controller action.
 * 
 * @TODO on any show/fixture def change; reload the whole page, possibly.
 *
 * Forwards generated by this action:
 * <attributes>
 * success - displays entry page
 * </attributes>
 *
 * @version         $Id$
 * @author          knoxg
 */
public class FancyControllerAction
    extends Action {
    /** A revision marker to be used in exception stack traces. */
    public static final String _revision = "$Id$";

    /** Logger instance for this class */
    private static final Logger logger = Logger.getLogger(FancyControllerAction.class);

    public static final long RELOAD_THRESHOLD = 5 * 1024 * 1024; // reload iframe after 5MB data sent
    
    /** Thing that sends updates to a webpage without using polling. 
     * 
     * @author knoxg
     *
     */
    public static class CometPipe implements OutputStreamListener {
    	long pageId;
    	String panel;
    	long bytesSent; // possibly reload the iframe when an excessive amount of data has been sent
    	boolean open;
    	
    	public CometPipe(long pageId, String panel) {
    		this.pageId = pageId;
    		this.panel = panel;
    		this.bytesSent = 0;
    		this.open = true;
    	}
    	
    	public boolean isOpen() { return open; }
    	public void close() { open = false; }

    	
    	// OutputStreamListener methods. error() is never invoked
		public void start() { }
		public void bytesWritten(int bytesWritten) { bytesSent += bytesWritten; }
		public void error(String message) {	}
		public void done() { }
    	
    	//HttpServletRequest request;
    	//HttpServletResponse response;
    	 
    }
    
    static long lastOpenPage=0;
    
    /* We have one cometPipe per page */
    ConcurrentHashMap<Long, CometPipe> cometPipes = new ConcurrentHashMap();

    
    public static class RecordingPlaybackShow extends Show {
    	Recording recording;
    	public RecordingPlaybackShow(Controller controller, Recording recording) {
    		super(-1, controller, "Recording", 0L, null);
    		this.recording = recording;
    	}
    	@Override
		public void play() {
    		while (!isCancelled()) {
	    		for (int i=0; i<recording.getFrames().size(); i++) {
	    			Frame f = recording.getFrames().get(i);
	    			for (Command c : f.getCommands()) {
	    				c.run();
	    			}
	    			recording.setCurrentFrameIndex(i);
	    			if (isCancelled()) { break; }
	    			waitFor(100); // @TODO allow speed to be set somewhere
	    		}
    		}
		}
		@Override
		public void pause() {
			// TODO Auto-generated method stub
		}
		@Override
		public void stop() {
			// TODO Auto-generated method stub
		}
    }
    
    public void setPanelAttributes(Map result, String panel, int universeIdx, Recording recording) {
    	AppConfig appConfig = AppConfig.getAppConfig();
    	Controller controller = appConfig.getController();
		if (panel.equals("dmxPanel")) {
			Universe u = controller.getUniverse(universeIdx);
    		String dmxValues = "";
    		for (int i=1; i<=255; i++) {
    			dmxValues+=u.getDmxChannelValue(i) + ",";
    		}
    		SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss.SSS");
    		result.put("now", sdf.format(new Date(u.getTime())));
    		result.put("dmxValues", dmxValues);

			/*
			int[] d = u.getAllDmxChannelValues();
			String j = "";
			for (int i=1; i<=255; i++) { j += d[i] + ","; }; 
			j += "";
			result.put("dmxValues", j);
			*/ 
			
		} else if (panel.equals("shwPanel")) {
			List<Show> shows = appConfig.getShows();
			List showResult = new ArrayList();
			for (int i=0; i<shows.size(); i++) {
				Show show = shows.get(i);
				HashMap m = new HashMap();
				m.put("id", show.getId());
				m.put("state", show.getState().toString());
				if (show.getState()!=Show.State.SHOW_STOPPED) { 
    				m.put("time", show.getShowTime());
    				m.put("label", show.getLabel());
    				m.put("length", show.getLength());
				}
				showResult.add(m);
			}
			AudioSource audioSource = appConfig.getAudioSource();
			float[] bmt = audioSource.getBassMidTreble();
			HashMap m = new HashMap();
			m.put("b", bmt[0]);
			m.put("m", bmt[1]);
			m.put("t", bmt[2]);
			result.put("audio", m);
			result.put("shows", showResult);

		} else if (panel.equals("fixPanel")) {
			List fixValues = new ArrayList();
		    for (Fixture f : controller.getFixtures()) {
    			FixtureController fc = f.getFixtureController();
		    	ChannelMuxer cm = f.getChannelMuxer();
		    	FixtureOutput fo = cm.getOutput();
		    	HashMap m = new HashMap();
		    	Color c = fo.getColor();
		    	m.put("c", getColorHexString(c));
		    	m.put("d", fo.getDim());
		    	Double pan = fo.getPan(); 
		    	if (pan!=null) { 
		    		m.put("p", twoDigits(fo.getPan())); 
		    		m.put("ap", twoDigits(fo.getActualPan()));
		    	}
		    	Double tilt = fo.getTilt(); 
		    	if (tilt!=null) { 
		    		m.put("t", twoDigits(fo.getTilt()));
		    		m.put("at", twoDigits(fo.getActualTilt()));
		    	}
		    	Double strobe = fo.getStrobe(); 
		    	if (strobe!=null) { 
		    		m.put("s", twoDigits(strobe)); 
		    	}
		    	fixValues.add(m);
		    	if (fc.getCustomControls()!=null && fc.getCustomControls().size()>0) {
		    		ArrayList ccs = new ArrayList();
		    		for (CustomControl cc : fc.getCustomControls()) {
		    			ccs.add(cc.getValue());
		    		}
		    		m.put("ccs", ccs);
		    	}
		    }
		    result.put("fixValues", fixValues);

		} else if (panel.equals("logPanel")) {
    		List exceptions = new ArrayList();
    		addExceptions(exceptions, "appConfig", appConfig.getAppConfigExceptions());
    		addExceptions(exceptions, "audio", controller.getAudioController().getExceptions());
    		addExceptions(exceptions, "audioSource", appConfig.getAudioSourceExceptions());
    		addExceptions(exceptions, "dmx", appConfig.getDmxDeviceExceptions());
    		addShowExceptions(exceptions, appConfig.getShowExceptions());
    		result.put("exceptions", exceptions);
    		result.put("stopPollRequests", Boolean.TRUE);

		} else if (panel.equals("cnfPanel") || panel.equals("lgoPanel")) {
			result.put("stopPollRequests", Boolean.TRUE);
		}
		
		result.put("logCount", appConfig.getLogCount());
		if (recording!=null) { 
    		result.put("currentFrame", recording.getCurrentFrameIndex());
    		result.put("totalFrames", recording.getFrames().size());
		}		
    }
    
    
    
    /**
     * Perform this struts action. See the javadoc for this
     * class for more details.
     *
     * @param mapping The struts ActionMapping that triggered this Action
     * @param actionForm An ActionForm (if available) holding user input for this Action
     * @param request The HttpServletRequest for this action
     * @param response The HttpServletResponse for this action
     *
     * @return An ActionForward representing the result to return to the end-user
     *
     * @throws Exception If an exception occurred during action processing
     */
    @SuppressWarnings({ "unchecked", "rawtypes" })
	public ActionForward execute(ActionMapping mapping, ActionForm actionForm, HttpServletRequest request, HttpServletResponse response)
        throws Exception 
    {
		HttpSession session = request.getSession();
		User user = (User) session.getAttribute("user");
		
		int currentBank = 0;
		Integer currentBankInt = (Integer) session.getAttribute("currentBank");
		if (currentBankInt!=null) { currentBank = currentBankInt; }
		int universeIdx = currentBank / 2;
		
		Recording recording = (Recording) session.getAttribute("recording");
		
		Command command = null;
		AppConfig appConfig = AppConfig.getAppConfig();
		String forward = "json";
    	Map form = new HashMap();
    	Struct.setFromRequest(form, request);
    	Map result = new HashMap();

    	Controller controller = appConfig.getController();
		Frame currentFrame = null;
		if (recording!=null) { 
			currentFrame = recording.getCurrentFrame(); 
		} else {
			// commands performed by this Action class are now performed
			// within a dummy recording, to ensure consistency with
			// actual recording behaviour.
			Recording dummyRecording = new Recording(controller);
			dummyRecording.addFrame(new Frame(dummyRecording));
			currentFrame = dummyRecording.getCurrentFrame();
		}
    	
    	String action = request.getParameter("action");
    	String fixtureIdString = request.getParameter("fixtureId");
    	int fixtureId = -1;
    	Fixture fixture = null;
    	FixtureController fixtureController = null;
    	if (!Text.isBlank(fixtureIdString)) { 
    		fixtureId = Integer.parseInt(fixtureIdString);
    		fixture = controller.getFixtures().get(fixtureId);
    		fixtureController = fixture.getFixtureController();
    	}
    	if (action==null) { action = ""; }
    	if ("true".equals(appConfig.getProperty("benchmark.browser.enabled"))) {
    		String lrid=request.getParameter("lrid"); // lastRequestId
    		String lrd=request.getParameter("lrd");   // lastRequestDuration
    		String lru=request.getParameter("lru");   // lastRequestPanelUpdateTime
    		String trst=request.getParameter("trst"); // thisRequestStartTime
    		Benchmark benchmark = (Benchmark) request.getAttribute("benchmark");
    		if (benchmark!=null) { benchmark.annotate("lrid=" + lrid + ",lrd=" + lrd + ",lru=" + lru + ",trst=" + trst); }
    	}
    	
    	if (action.equals("") || action.equals("editRecording")) {
    		long thisPageId=lastOpenPage++;  // probably a race condition
    		List shows = new ArrayList();
    		List fixtures = new ArrayList();
    		Map stage = new HashMap();
    		Map fixtureDefs = new HashMap();
    		Stage activeStage = appConfig.getActiveStage();
    		if (activeStage!=null) {
    			stage.put("fixPanelBackgroundImage", activeStage.getFixPanelBackgroundImage());
    		}
    		
    		for (Fixture f : controller.getFixtures()) {
    			FixtureDef fd = f.getFixtureDef();
    			FixtureController fc = f.getFixtureController();
    			String fdName = fd.getClass().getName();
    			Map m = new HashMap();
    			m.put("universeIdx", f.getUniverse().getUniverseIdx());
    			m.put("dmxOffset", f.getStartDmxChannel());
    			m.put("name", f.getName());
    			m.put("sortOrder", f.getSortOrder()); 
    			m.put("type", fdName);
    			m.put("fpType",  f.getFixPanelType());
    			Long[] fixPanelPosition = f.getFixPanelPosition();
    			if (fixPanelPosition[0]!=null) {
    				m.put("x", fixPanelPosition[0]); 
    				m.put("y", fixPanelPosition[1]);
    			}
    			fixtures.add(m);
    			if (!fixtureDefs.containsKey(fdName)) {
    				Map m2 = new HashMap();
    				m2.put("dmxChannels", fd.getNumDmxChannels());
        			m2.put("img16", fd.getHtmlImg16());
        			m2.put("img32", fd.getHtmlImg32());
        			m2.put("label", fd.getHtmlLabel());
    				m2.put("panRange", fd.getPanRange());
    				m2.put("tiltRange", fd.getTiltRange());
    				m2.put("minStrobeHertz", fd.getMinimumStrobeHertz());
    				m2.put("maxStrobeHertz", fd.getMaximumStrobeHertz());
    				List cds = new ArrayList();
    				for (int i=0; i<fd.getChannelDefs().size(); i++) {
    					ChannelDef cd = fd.getChannelDefs().get(i);
    					Map m3 = new HashMap();
    					//m3.put("type", cd.getClass().getName());
    					m3.put("img", cd.getHtmlImg());
    					m3.put("label", cd.getHtmlLabel());
    					m3.put("dmxOffset", cd.getOffset());
    					cds.add(m3);
    				}
    				m2.put("channelDefs", cds);
    				if (fc.getCustomControls()!=null) {
	    				List ccs = new ArrayList();
	    				for (int i=0; i<fc.getCustomControls().size(); i++) {
	    					CustomControl cc = fc.getCustomControls().get(i);
	    					Map m4 = new HashMap();
	    					m4.put("uiType", cc.getUIType().toString());
	    					m4.put("label", cc.getLabel());
	    					if (cc.getLeft()!=null) {
	    						m4.put("left", cc.getLeft());
	    						m4.put("top", cc.getTop());
	    					}
	    					if (cc.getImage()!=null) {
	    						m4.put("image", fd.getImagePath() + cc.getImage());
	    					}
	    					ccs.add(m4);
	    				}
	    				m2.put("customControls", ccs);
    				}
    				
    				fixtureDefs.put(fdName, m2);
    			}
    		}
    		for (int i=0; i<appConfig.getShows().size(); i++) {
    			Show s = appConfig.getShows().get(i);
    			Map m = new HashMap();
    			m.put("id", new Long(s.getId()));
    			m.put("name", s.getName());
    			m.put("description", s.getDescription());
    			m.put("showGroupId", s.getShowGroupId());
    			shows.add(m);
    		}
    		Struct.sortStructuredList(shows, "showGroupId");
    		String dmxValues = "";
    		for (int i=1; i<=Universe.MAX_CHANNELS; i++) {
    			dmxValues+=controller.getUniverse(universeIdx).getDmxChannelValue(i) + ",";
    		}
			List fixValues = new ArrayList();
		    for (Fixture f : controller.getFixtures()) {
    			FixtureController fc = f.getFixtureController();
		    	ChannelMuxer cm = f.getChannelMuxer();
		    	FixtureOutput fo = null;
		    	HashMap m = new HashMap();
		    	try {
		    		fo = cm.getOutput();
			    	Color c = fo.getColor();
			    	m.put("c", getColorHexString(c));
			    	m.put("d", fo.getDim());
			    	Double pan = fo.getPan(); 
			    	if (pan!=null) { 
			    		m.put("p", twoDigits(fo.getPan())); 
			    		m.put("ap", twoDigits(fo.getActualPan()));
			    	}
			    	Double tilt = fo.getTilt(); 
			    	if (tilt!=null) { 
			    		m.put("t", twoDigits(fo.getTilt()));
			    		m.put("at", twoDigits(fo.getActualTilt()));
			    	}
			    	Double strobe = fo.getStrobe(); 
			    	if (strobe!=null) { 
			    		m.put("s", twoDigits(strobe)); 
			    	}
			    	if (fc.getCustomControls()!=null && fc.getCustomControls().size()>0) {
			    		ArrayList ccs = new ArrayList();
			    		for (CustomControl cc : fc.getCustomControls()) {
			    			ccs.add(cc.getValue());
			    		}
			    		m.put("ccs", ccs);
			    	}
		    	} catch (Exception e) {
		    		// faulty channel muxer, just send zeroes for everything
		    		appConfig.addAppConfigException(e);
		    		m.put("c", "000000");
		    		m.put("d", 0);
		    		m.put("p", 0); m.put("ap", 0);
		    		m.put("t", 0); m.put("at", 0);
		    		// @TODO: this could also break
		    		m.put("s", 0); 
		    		if (fc.getCustomControls()!=null && fc.getCustomControls().size()>0) {
			    		ArrayList ccs = new ArrayList();
			    		for (CustomControl cc : fc.getCustomControls()) {
			    			ccs.add(0);
			    		}
			    		m.put("ccs", ccs);
			    	}
		    		
		    	}

		    	fixValues.add(m);
		    }
		    if (request.getAttribute("initMessage")==null) {
		    	// may be set by other actions returning to config page
		    	request.setAttribute("initMessage", "Messages");
		    }
		    recording = null;
		    if (action.equals("editRecording")) {
		    	// stop all shows
		    	
		    	long showDefId = Long.parseLong(request.getParameter("showDefId"));
		    	ShowDefDAO showDefDAO = new ShowDefDAO(appConfig.getJdbcTemplate());
		    	ShowDefTO showDef = showDefDAO.getShowDef(showDefId);
		    	RecordedShow showObj = null;
		    	
		    	// this could fail if the active stage was not the same
		    	// active stage when the show was recorded
		    	
				try {
					//logger.debug("Loading scripted show class '" + showDef.getName() + "' from database");
					//getScriptEngine().eval(showDef.getScript(), showScriptContext);
					String testScript =
						//"import com.randomnoun.dmx.Show;\n" +
						"import " + showDef.getClassName() + ";\n" +
						"return " + showDef.getClassName() + ".class;\n" ;
					Class clazz = (Class) appConfig.getScriptEngine().eval(testScript, appConfig.getScriptContext());
					if (RecordedShow.class.isAssignableFrom(clazz)) {
						Controller testController = new Controller();
						Properties nullProperties = new Properties();
						Constructor constructor = clazz.getConstructor(long.class, Controller.class, Properties.class);
						showObj = (RecordedShow) constructor.newInstance(0L, testController, nullProperties);
						recording = showObj.getRecording(controller);
						
					} else {
						AppConfigException ace = new AppConfigException("Error instantiating recorded show " + showDef.getId() + ": '" + showDef.getName() + "'; className='" + showDef.getClassName() + "' does not extend com.randomnoun.dmx.editor.RecordedShow");
						appConfig.addAppConfigException(ace);
						logger.error(ace.getMessage()); 
					}
					// AppConfigException ace = new AppConfigException("Error instantiating recorded show " + showDef.getId() + ": '" + showDef.getName() + "'");
				} catch (Exception e) {
					appConfig.addAppConfigException(new AppConfigException("Error instantiating recorded show " + showDef.getId() + ": '" + showDef.getName() + "'", e));
					logger.error(e);
				}

		    	// recording = new Recording(controller);
				if (recording==null) {
					request.setAttribute("initMessage", "Could not load recording; view Logs panel for details");
					// remove from session ?
					
					
				} else {
					for (Show s : appConfig.getShows()) {
		    			if (!appConfig.getShow(s.getId()).getState().equals(Show.State.SHOW_STOPPED)) {
		    				appConfig.cancelShow(s.getId());
		    			}
					}
					ArrayList fixtureIds = new ArrayList();
		    		for (Fixture f : recording.getModifiedFixtures()) { fixtureIds.add(controller.getFixtures().indexOf(f)); }
					recording.setCurrentFrameIndex(0);
		    		logger.info("Running " + recording.getCurrentFrame().getCommands().size() + " commands on initial frame");
		    		for (Command c : recording.getCurrentFrame().getCommands()) { c.run(); }
					request.setAttribute("initMessage", "Updating recording " + showDefId + ": '" + showDef.getName() + "'");
		    		request.setAttribute("recCurrentFrame", recording.getCurrentFrameIndex());
		    		request.setAttribute("recTotalFrames", recording.getFrames().size());
		    		request.setAttribute("panel", "fixPanel");
		    		request.setAttribute("recShowDefId", showDefId);
		    		request.setAttribute("recShowDefName", showDef.getName());
		    		request.setAttribute("recModifiedFixtureIds", fixtureIds);
		    		request.setAttribute("recModifiedDmxChannels", recording.getModifiedDmxChannels());
		    		request.setAttribute("reqRecording", recording); // request.recording doesn't work in JSTL
		    		session.setAttribute("recording", recording);
				}
		    };
		    if (recording==null) {
		    	request.setAttribute("recCurrentFrame", 0L);
	    		request.setAttribute("recTotalFrames", 0L);
		    }
		    
		    Map version = getVersionData();
	    	request.setAttribute("dmxValues", dmxValues);
    		request.setAttribute("fixValues", fixValues);
    		request.setAttribute("fixtures", fixtures);
	    	request.setAttribute("controller", controller);
	    	//request.setAttribute("universe", controller.getUniverse());
    		request.setAttribute("fixtureDefs", fixtureDefs);
    		request.setAttribute("stage", stage);
    		request.setAttribute("shows", shows);
    		request.setAttribute("version", version);
    		request.setAttribute("panel", request.getParameter("panel"));
    		request.setAttribute("javadocUrl", appConfig.getProperty("fancyController.javadocUrl"));
    		request.setAttribute("pageId", thisPageId);
    		request.setAttribute("logCount", appConfig.getLogCount());
    		forward="success";

    	} else if (action.equals("poll")) {
    		// just poll the goddamn thing every second or so.
    		String panel = request.getParameter("panel");
    		long pageId = Long.parseLong(request.getParameter("pageId"));
    		CometPipe cometPipe = cometPipes.get(pageId);
    		if (cometPipe==null) { result.put("reloadIframe", true); }
    		else if (!cometPipe.panel.equals(panel)) {
    			// alternatively, could change the panel of this cometPipe
    			// English. I've heard of it.
    			// @TODO rename all these things as IFrameResponses before I commit it to CVS
    			result.put("reloadIframe", true); 
    		}
    		
    		result.put("panel", panel);
    		result.put("serverTime", System.currentTimeMillis());
    		setPanelAttributes(result, panel, universeIdx, recording);
    		
    		/*
    		String eventMaskString = request.getParameter("eventMask");
    		String since = Long.parseLong(request.getParameter("since"));
    		List events = appConfig.getEvents(eventMask, since);
    		if (events!=null) {
    			request.setAttribute("json", Struct.structuredListToJson(events));
    		} else {
    			// NB: this could make the server appear unresponsive if this consumes
    			// all the HTTP-handling threads
    			appConfig.getEventMonitor(eventMask).wait(20*1000); // fire off another AJAX request in 20seconds regardless
    			List events = appConfig.getEvents(eventMask, since);
    			request.setAttribute("json", Struct.structuredListToJson(events));
    		}
    		forward="json";
    		*/
    	
    	} else if (action.equals("iframe")) {
    		// keep a connection open to the browser (CometPipe) until 
    		//   a) we start getting IOExceptions (flag the pipe as invalid and reopen it on the next poll), or
    		//   b) we send an excessive amount of data (reload the containing iframe, which hopefully frees up any memory taken up by the page)
    		//   c) we send a response for the wrong panel, which will also trigger an iframe reload
    		String panel = request.getParameter("panel");
    		long pageId = Long.parseLong(request.getParameter("pageId"));
    		CometPipe cometPipe = cometPipes.get(pageId);
    		if (cometPipe!=null) {
    			// this should never happen. maybe. could just terminate the other one.
    			logger.warn("Two cometPipes requested on pageId " + pageId + "; closing existing pipe");
    			cometPipe.close();
    		}
    		
    		// @TODO we don't keep these around. which i guess is fair enough ?
    		cometPipe = new CometPipe(pageId, panel);
    		logger.debug("CometPipe for pageId=" + pageId + " opened");
    		OutputStream os = response.getOutputStream();
    		MonitoredOutputStream mos = new MonitoredOutputStream(os, cometPipe);
    		PrintWriter pw = new PrintWriter(mos);
    		//pw.println("Content-Encoding: UTF8 or something");
    		//PrintWriter pw = response.getWriter(); // I suspect this isn't going to work.
    		while (cometPipe.isOpen()) {
    			Map resultMap = new HashMap();
    			resultMap.put("panel", panel);
    			resultMap.put("serverTime", System.currentTimeMillis());
    			setPanelAttributes(resultMap, panel, universeIdx, recording);
    			
    			// @TODO make this much more compact (diffs only?)
    			pw.println("<script>top.updatePanelComet(" + Struct.structuredMapToJson(resultMap) + ");</script>\n");
    			pw.flush();
    			Boolean b = (Boolean) resultMap.get("stopPollRequests");
    			if (pw.checkError()) { cometPipe.close(); }
    			else if (b!=null && b.booleanValue()) { cometPipe.close(); }
    			else if (cometPipe.bytesSent > RELOAD_THRESHOLD) {
    				pw.println("<script>top.reloadCometIframe();</script>");
    				pw.flush();
    				logger.debug("CometPipe for pageId=" + pageId + " has sent " + cometPipe.bytesSent + " bytes; reloading");
    				cometPipe.close(); 
    			} else {
    				// logger.info("Written " + cometPipe.bytesSent + " bytes to pipe " + pageId);
	    			// @TODO should wait until the cometPipe closes, or we see a state change in this panel
    				// or we hit a timeout
	    			try {
	    				Thread.sleep(50);
	    			} catch (InterruptedException ie) {
	    				
	    			}
	    			
    			}
    		}
    		logger.debug("CometPipe for pageId=" + pageId + " closed");
    		forward = "null"; // maps to NullForward
    		
    	} else if (action.equals("setDmxValues")) {
			// old method (one parameter per value) - used by manual controller  only
    		List dmxValues = (List) form.get("dmx");
    		byte[] dmxData = new byte[512];
	    	for (int i=1; i<=255; i++) {
	    		String value = (String) dmxValues.get(i);
	    		if (!Text.isBlank(value)) {
	    			controller.getUniverse(0).setDmxChannelValue(i, (int) new Long(value).longValue());
	    		}
	    	}
	    	request.setAttribute("message", "DMX values set");

    	} else if (action.equals("setDmxValues2")) {
    		// used by manual controller  only
			String dmxValuesString = (String) form.get("values");
			String[] dmxValues = dmxValuesString.split(",");
			for (int i=1; i<=255; i++) {
				int value = Integer.parseInt(dmxValues[i-1]);
				if (value>=0 && value <=255) {
					controller.getUniverse(0).setDmxChannelValue(i, value);
				}
			}
			result.put("message", "DMX channels set");

			
		//*************************************************
		// All recordable actions below should execute by calling the
		// .run() method on the command object, to ensure that what we're
		// recording is what is executing.
		//*************************************************
			
    	} else if (action.equals("setDmxValue")) {
    		int universe = universeIdx;
    		if (request.getParameter("universe")!=null) {
    			universe = Integer.parseInt(request.getParameter("universe"));
    		}
    		int channel = Integer.parseInt(request.getParameter("channel"));
    		int value = Integer.parseInt(request.getParameter("value"));
    		if (value>=0 && value<=255) {
    			command = new DmxValueCommand(currentFrame, universe, channel, value);
    			if (recording!=null) { recording.addCommand(command); }
    			// controller.getUniverse().setDmxChannelValue(channel, value);
    			command.run(); 
    			result.put("message", "DMX channel " + channel + " set to " + value);
    		} else {
    			result.put("message", "Value out of range");
    		}
	    	
    	} else if (action.equals("blackOut")) {
    		if (fixtureId == -1) {
    			boolean showsStopped = false;
	    		for (Show s : appConfig.getShows()) {
	    			// i.e. SHOW_RUNNING or SHOW_STOPPED_WITH_EXCEPTION
	    			if (!appConfig.getShow(s.getId()).getState().equals(Show.State.SHOW_STOPPED)) {
	    				appConfig.cancelShow(s.getId());
	    				showsStopped = true;
	    			}
    			}
	    		controller.blackOut();
    			result.put("message", "controller blackOut" + (showsStopped ? " and shows stopped" : ""));
    			
    		} else {
	    		fixtureController.blackOut();
	    		result.put("message", "fixture " + fixtureId + " '" + fixture.getName() + "' blackOut");
    		}
    	} else if (action.equals("setColor")) {
    		int red = Integer.parseInt(request.getParameter("r"));
    		int green = Integer.parseInt(request.getParameter("g"));
    		int blue = Integer.parseInt(request.getParameter("b"));
    		fixtureController.setColor(new Color(red, green, blue));
    		result.put("message", "fixture " + fixtureId + " '" + fixture.getName() + "' color set to " + red + ", " + green + ", " + blue);
    		
    	} else if (action.equals("setPan")) {
    		double pan = Double.parseDouble(request.getParameter("p"));
    		fixtureController.panTo(pan);
    		result.put("message", "fixture " + fixtureId + " '" + fixture.getName() + "' pan set to " + pan);
    		
    	} else if (action.equals("setTilt")) {
    		double tilt = Double.parseDouble(request.getParameter("t"));
    		fixtureController.tiltTo(tilt);
    		result.put("message", "fixture " + fixtureId + " '" + fixture.getName() + "' tilt set to " + tilt);
    		
    	} else if (action.equals("startShow")) {
    		// TODO: don't start if recording in progress
    		if (recording==null) {
	    		int showId = Integer.parseInt(request.getParameter("showId"));
	    		Show show = appConfig.getShow(showId);
	    		appConfig.startShow(showId);
	    		result.put("message", "Show " + showId + " '" + show.getName() + "' started " +
	    			(show.getLength()==Long.MAX_VALUE ? " (continuous)" : " (length=" + show.getLength() + "msec)"));
    		} else {
    			result.put("message", "Cannot play shows whilst recording is in progress");
    		}
    		
    	} else if (action.equals("cancelShow")) {
    		int showId = -1;
    		if (!Text.isBlank(request.getParameter("showId"))) {
    			showId = Integer.parseInt(request.getParameter("showId"));
    		}
    		if (showId != -1) {
	    		Show show = appConfig.getShow(showId);
	    		appConfig.cancelShow(showId);
	    		result.put("message", "Show " + showId + " '" + show.getName() + "' cancel requested");
    		} else {
    			for (Show s : appConfig.getShows()) {
    				appConfig.cancelShow(s.getId());
    			}
    			result.put("message", "Cancel all shows requested");
    		}

    	} else if (action.equals("cancelShowGroup")) {
    		int showGroupId = Integer.parseInt(request.getParameter("showGroupId"));
    		appConfig.cancelShowGroup(showGroupId);
    		result.put("message", "ShowGroup " + showGroupId + " cancel requested");
    		
    	} else if (action.equals("fixtureBlackout")) {
    		List<Fixture> fixtures = getFixtureList(controller, request.getParameter("fixtureIds"));
    		Command c = new FixtureBlackoutCommand(currentFrame, fixtures);
    		if (recording!=null) { recording.addCommand(c); }
    		c.run();
    		/*
    		for (String iterationId : fixtureIdStrings) {
    			Fixture f = controller.getFixture(Integer.parseInt(iterationId));
    			f.blackOut();
    			c++;
    		}
    		*/
    		result.put("message", fixtures.size() + " fixture(s) blacked out");

    	} else if (action.equals("fixtureDim")) {
    		List<Fixture> fixtures = getFixtureList(controller, request.getParameter("fixtureIds"));
    		int v = Integer.parseInt(request.getParameter("v"));
    		Command c = new FixtureDimCommand(currentFrame, fixtures, v);
    		if (recording!=null) { recording.addCommand(c); }
    		c.run();
    		/*
    		for (String iterationId : fixtureIdStrings) {
    			Fixture f = controller.getFixture(Integer.parseInt(iterationId));
    			f.getFixtureController().setMasterDimmer(v);
    			c++;
    		}
    		*/
    		result.put("message", fixtures.size() + " fixture(s) set to " + (100*v/255) + "%");

    	} else if (action.equals("fixtureStrobe")) {
    		List<Fixture> fixtures = getFixtureList(controller, request.getParameter("fixtureIds"));
    		int v = Integer.parseInt(request.getParameter("v"));
    		Command c = new FixtureStrobeCommand(currentFrame, fixtures, v);
    		if (recording!=null) { recording.addCommand(c); }
    		c.run();
    		/*
    		if (v==0) {
        		for (String iterationId : fixtureIdStrings) {
        			Fixture f = controller.getFixture(Integer.parseInt(iterationId));
        			try {
        				f.getFixtureController().unsetStrobe();
        				c++;
        			} catch (Exception e) { failed++; }
        		}
        		result.put("message", fixtures.size() + " fixture(s) strobe disabled" + (failed==0 ? "" : " (" + failed + " unsupported)"));
    		} else {
        		for (String iterationId : fixtureIdStrings) {
        			Fixture f = controller.getFixture(Integer.parseInt(iterationId));
        			try {
        				f.getFixtureController().setStrobe(v);
        				c++;
        			} catch (Exception e) { failed++; }
        		}
        		result.put("message", fixtures.size() + " fixture(s) strobe set to " + (100*v/255) + "%" + (failed==0 ? "" : " (" + failed + " unsupported)"));
    		}
    		*/
    		result.put("message", fixtures.size() + " fixture(s) strobe " +
    		  (v==0 ? "disabled" : "set to " + (100*v/255) + "%"));
    		
    	} else if (action.equals("fixtureColor")) {
    		List<Fixture> fixtures = getFixtureList(controller, request.getParameter("fixtureIds"));
    		String colorString = request.getParameter("color");
    		Color color = new Color(
        			Integer.parseInt(colorString.substring(0, 2), 16),
        			Integer.parseInt(colorString.substring(2, 4), 16),
        			Integer.parseInt(colorString.substring(4, 6), 16));
    		Command c = new FixtureColorCommand(currentFrame, fixtures, color);
    		if (recording!=null) { recording.addCommand(c); }
    		c.run();
    		/*
    		for (String iterationId : fixtureIdStrings) {
    			Fixture f = controller.getFixture(Integer.parseInt(iterationId));
    			f.getFixtureController().setColor(color);
    			c++;
    		}
    		*/
    		result.put("message", fixtures.size() + " fixture(s) set to #" + colorString);

    	} else if (action.equals("fixtureAim")) {
    		List<Fixture> fixtures = getFixtureList(controller, request.getParameter("fixtureIds"));
    		double x = Double.parseDouble(request.getParameter("x"));
    		double y = Double.parseDouble(request.getParameter("y"));
    		Command c = new FixturePanTiltCommand(currentFrame, fixtures, x, y);
    		if (recording!=null) { recording.addCommand(c); }
    		c.run();
    		// TODO: probably express this as minPan/maxPan later
    		// if same pan/tilt range for all fixtures, keep degrees info for message
    		
    		boolean sameRange = true;
    		int lastPanRange=-1, lastTiltRange=-1;
    		FixtureDef fd = null;
    		for (Fixture f : fixtures) {
    			fd = f.getFixtureDef();
    			//f.getFixtureController().panTo(fd.getPanRange() * x / 100);
    			//f.getFixtureController().tiltTo(fd.getTiltRange() * y / 100);
    			if (lastPanRange==-1) { lastPanRange=fd.getPanRange(); } else { sameRange &= fd.getPanRange()==lastPanRange; };
    			if (lastTiltRange==-1) { lastTiltRange=fd.getTiltRange(); } else { sameRange &= fd.getTiltRange()==lastTiltRange; };
    		}
    		DecimalFormat df = new DecimalFormat("0.00");
			result.put("message", fixtures.size() + " fixture(s) set to " +
				"pan " + (sameRange ? " " + df.format(fd.getPanRange()*x/100) + "&deg;" : "") + "(" + df.format(x) + "%)" + 
				", tilt " + (sameRange ? " " + df.format(fd.getTiltRange()*y/100) + "&deg;" : "") + "(" + df.format(y) + "%)");
    	
    	} else if (action.equals("customControl")) {
    		List<Fixture> fixtures = getFixtureList(controller, request.getParameter("fixtureIds"));
    		int controlId = Integer.parseInt(request.getParameter("controlId"));
    		int value=Integer.parseInt(request.getParameter("value"));
    		Command c = new FixtureCustomControlCommand(currentFrame, fixtures, controlId, value);
    		if (recording!=null) { recording.addCommand(c); }
    		c.run();
    		/*
    		FixtureDef fd = null;
    		for (String iterationId : fixtureIdStrings) {
    			Fixture f = controller.getFixture(Integer.parseInt(iterationId));
    			if (fd==null) { fd = f.getFixtureDef(); } 
    			else if ( fd != f.getFixtureDef()) { logger.warn("Inconsistent fixtureDefs setting customControls (fixtureIds=" + request.getParameter("fixtureIds") + ")"); }
    			FixtureController fc = f.getFixtureController();
    			fc.getCustomControls().get(controlId).setValueWithCallback(value);
    		}
    		*/
    		result.put("message", fixtures.size() + " fixture(s) updated");
			
    	} else if (action.equals("resetAudio")) {
    		AudioController audioController = appConfig.getController().getAudioController();
    		audioController.close();
    		audioController.open();
    		result.put("message", "Audio controller re-initialised");

    		/*
    	} else if (action.equals("resetDMX")) {
    		DmxDevice dmxDevice = appConfig.get(key) audioController = appConfig.getController().getAudioController();
    		audioController.close();
    		audioController.open();
    		result.put("message", "Audio controller re-initialised");
    		*/
    	
    	} else if (action.equals("startRecording")) {
    		// triggered by cnfPanel 
    		for (Show s : appConfig.getShows()) {
    			if (!appConfig.getShow(s.getId()).getState().equals(Show.State.SHOW_STOPPED)) {
    				appConfig.cancelShow(s.getId());
    			}
			}	
    		recording = new Recording(controller);
    		recording.addFrame(new Frame(recording));
    		result.put("message", "Recording started");
    		result.put("currentFrame", recording.getCurrentFrameIndex());
    		result.put("totalFrames", recording.getFrames().size());
    		session.setAttribute("recording", recording);
    		
    	} else if (action.equals("stopRecording")) {
    		// triggered by cnfPanel.
    		String showDefIdString = request.getParameter("recShowDefId");
    		String showName = request.getParameter("showName");
    		String className = "";
    		
    		if (showName==null) {
    			result.put("hideRecFrame", Boolean.TRUE);
    			result.put("message", "Recording cancelled");
    			session.removeAttribute("recording");
    			
    		} else {

	    		String defaultPackage = AppConfig.getAppConfig().getProperty("recordedShow.defaultPackage");
	        	if (Text.isBlank(defaultPackage)) { defaultPackage = "com.example.dmx.show.editor"; }    		
	    		
	    		ShowDefDAO showDefDAO = new ShowDefDAO(appConfig.getJdbcTemplate());
	    		long showDefId=-1;
	    		if (!Text.isBlank(showDefIdString)) { showDefId = Long.parseLong(showDefIdString); }    			
	    		ShowDefTO showDefTO = null;
	    		if (showDefId!=-1) { 
	    			showDefTO = showDefDAO.getShowDef(showDefId);
	    			if (!showDefTO.getName().equals(showName)) {
	    				// different show name; create a new show rather than updating existing
	    				showDefTO = null;
	    			}
	    		}
	    		if (showDefTO == null) {
	    			showDefTO = new ShowDefTO();
	        		boolean upper = true;
	        		for (int i=0; i<showName.length(); i++) {
	        			char ch = showName.charAt(i);
	        			if (ch == ' ') {
	        				upper = true;
	        			} else {
	        				if (Character.isJavaIdentifierPart(ch)) {
	        					className += upper ? Character.toUpperCase(ch) : Character.toLowerCase(ch);
	        				} else {
	        					className += "_";
	        				}
	        				upper = false;
	        			}
	        		}
	        		if (!Character.isJavaIdentifierStart(className.charAt(0))) { className = "_" + className; }
	        		className = className + "Show";
	        		
	        		// if className exists, then append numbers to it until it's unique
	        		int suffix = showDefDAO.getUniqueClassNameSuffix(defaultPackage, className);
	        		className = suffix == 0 ? className : className + suffix;
	        		showName = suffix == 0 ? showName : showName + " (" + suffix + ")";
	        		logger.info("Unique className='" + className + "'");
	        		
	        		showDefTO.setId(-1);
	    			showDefTO.setName(showName);
	        		showDefTO.setClassName(defaultPackage + "." + className);
	        		showDefTO.setRecorded(true);
	        		showDefTO.setJavadoc("/** A show recorded by " + request.getRemoteHost() + " on " + (new Date()).toString() + " */");    			
	    		}
	    		
	    		if (showDefTO.getId()==-1) {
	    			// new show
		    		InputStream is = this.getClass().getClassLoader().getResourceAsStream("default/recordedShowDef.java");
		    		if (is==null) { throw new IllegalStateException("Could not find resource 'default/recordedShowDef.java'"); }
		    		String showRecordingTemplate = new String(StreamUtils.getByteArray(is), "UTF-8");
		    		long defaultDelay = 200;
		    		String script = Text.replaceString(showRecordingTemplate, "{PACKAGENAME_GOES_HERE}", defaultPackage);
		    		script = Text.replaceString(script, "{USERNAME_GOES_HERE}", request.getRemoteHost());
		    		script = Text.replaceString(script, "{TIMESTAMP_GOES_HERE}", (new Date()).toString());
		    		script = Text.replaceString(script, "{CODE_GOES_HERE}", Text.indent("    ", recording.toJava()));
		    		script = Text.replaceString(script, "{SHOWNAME_GOES_HERE}", showName);
		    		script = Text.replaceString(script, "{CLASSNAME_GOES_HERE}", className);
		    		script = Text.replaceString(script, "{DEFAULT_DELAY_GOES_HERE}", String.valueOf(defaultDelay));
		    		showDefTO.setScript(script);
		    		showDefId = showDefDAO.createShowDef(showDefTO);
	
		    		ShowDAO showDAO = new ShowDAO(appConfig.getJdbcTemplate());
		    		ShowTO showTO = new ShowTO();
		    		showTO.setName(showName);
		    		showTO.setShowDefId(showDefId);
		    		showTO.setShowGroupId(showDAO.getLastShowGroupId());
		    		showTO.setStageId(appConfig.getActiveStage().getId());
		    		logger.info("Creating recorded show name='" + showName + "'");
		    		long showId = showDAO.createShow(showTO);
		    		logger.info("Created recorded show id=" + showId + ", name='" + showName + "'");
	    		} else {
	    			// update existing show
	    			List<String> lines = new ArrayList(Arrays.asList(showDefTO.getScript().split("\n")));
	    			int startIdx=-1, endIdx=-1;
	    			for (int i=0; i<lines.size(); i++) {
	    				if (startIdx==-1 && lines.get(i).indexOf("*** RECORDING DEFINITION START")!=-1) {
	    					startIdx = i;
	    				}
	    				if (endIdx==-1 && lines.get(i).indexOf("*** RECORDING DEFINITION END")!=-1) {
	    					endIdx = i;
	    				}
	    			}
	    			if (startIdx!=-1 && endIdx!=-1 && endIdx>startIdx) {
	    				for (int d = 0; d < endIdx - startIdx - 1; d++) {
	    					lines.remove(startIdx + 1);
	    				}
	    				lines.add(startIdx + 1, Text.indent("    ", recording.toJava()));
	    			} else {
	    				// arg.
	    				logger.error("Could not update recording (startIdx=" + startIdx + ", endIdx=" + endIdx + ")");
	    			}
	    			logger.info("=================== old show def:");
	    			logger.info(showDefTO.getScript());
	    			logger.info("=================== new show def:");
	    			logger.info(Text.join(lines, "\n"));
	    			
	    			showDefTO.setScript(Text.join(lines, "\n"));
	    			logger.info("Updating recorded show id=" + showDefTO.getId() + ", name='" + showDefTO.getName() + "'");
		    		showDefDAO.updateShowDef(showDefTO);
	    			logger.info("Updated recorded show id=" + showDefTO.getId() + ", name='" + showDefTO.getName() + "'");
		    		
	    			// TODO: create a show instance if one does not exist ?
	    		}
	    		session.removeAttribute("recording");
	    		// @TODO deal with any other recordings in progress by other users
	    		appConfig.reloadShows();
	    		
	    		// repopulate the show panel
	    		List shows = new ArrayList();
	    		for (int i=0; i<appConfig.getShows().size(); i++) {
	    			Show s = appConfig.getShows().get(i);
	    			Map m = new HashMap();
	    			m.put("id", new Long(s.getId()));
	    			m.put("name", s.getName());
	    			m.put("description", s.getDescription());
	    			m.put("showGroupId", s.getShowGroupId());
	    			shows.add(m);
	    		}
	    		Struct.sortStructuredList(shows, "showGroupId");
	    		result.put("shows", shows);
	    		result.put("message", "Recording stopped; saved as show definition '" + showName + "' in show group n" /*+ showTO.getShowGroupId()*/);
	    		
	    		/*
	    		for (int i=0; i<recording.getFrames().size(); i++) {
	    			Frame f = recording.getFrames().get(i);
	    			logger.info("Frame " + i + ": " + f.toString());
	    		}
	    		logger.info("=== or, in java:");
	    		logger.info(recording.toJava());
				*/
    		}

    	} else if (action.equals("addFrame")) {
    		if (appConfig.getShowNoEx(-1)!=null) { appConfig.cancelShow(-1); } // stop playback
    		Frame frame = new Frame(recording);
    		recording.addFrame(frame);
    		result.put("message", "Recording frame " + (recording.getCurrentFrameIndex()+1) + " of " + recording.getFrames().size());
    		result.put("currentFrame", recording.getCurrentFrameIndex());
    		result.put("totalFrames", recording.getFrames().size());

    	} else if (action.equals("deleteFrame")) {
    		if (appConfig.getShowNoEx(-1)!=null) { appConfig.cancelShow(-1); } // stop playback
    		if (recording.getFrames().size()>1) {
    			recording.getFrames().remove(recording.getCurrentFrameIndex());
    			if (recording.getCurrentFrameIndex()==recording.getFrames().size()) {
    				recording.setCurrentFrameIndex(recording.getFrames().size()-1);
    			}
    			for (Command c : recording.getCurrentFrame().getCommands()) { c.run(); }
    			result.put("message", "Frame deleted");
    		} else {
    			result.put("message", "Recording must have at least one frame");
    		}
    		

    	} else if (action.equals("nextFrame")) {
    		if (appConfig.getShowNoEx(-1)!=null) { appConfig.cancelShow(-1); } // stop playback
    		if (recording.getCurrentFrameIndex()==recording.getFrames().size()-1) {
    			Frame frame = new Frame(recording);
    			recording.addFrame(frame);
    		} else {
    			recording.setCurrentFrameIndex(recording.getCurrentFrameIndex() + 1);
    		}
    		logger.info("Running " + recording.getCurrentFrame().getCommands().size() + " commands on nextFrame");
    		for (Command c : recording.getCurrentFrame().getCommands()) { c.run(); }
    		result.put("message", "Recording frame " + (recording.getCurrentFrameIndex()+1) + " of " + recording.getFrames().size());
    		result.put("currentFrame", recording.getCurrentFrameIndex());
    		result.put("totalFrames", recording.getFrames().size());

    	} else if (action.equals("prevFrame")) {
    		if (appConfig.getShowNoEx(-1)!=null) { appConfig.cancelShow(-1); } // stop playback
    		int newFrameIndex = recording.getCurrentFrameIndex()-1;
    		if (newFrameIndex < 0) { newFrameIndex = 0; }
    		recording.setCurrentFrameIndex(newFrameIndex);
    		logger.info("Running " + recording.getCurrentFrame().getCommands().size() + " commands on prevFrame");
    		for (Command c : recording.getCurrentFrame().getCommands()) { c.run(); }
    		result.put("message", "Recording frame " + (recording.getCurrentFrameIndex()+1) + " of " + recording.getFrames().size());
    		result.put("currentFrame", recording.getCurrentFrameIndex());
    		result.put("totalFrames", recording.getFrames().size());
    		
    	} else if (action.equals("playRecording")) {
    		// play/pause recording
    		// create a temporary Show object, stick it in the appConfig, and run it.
    		if (appConfig.getShowNoEx(-1)!=null) {
    			// stop playback
    			appConfig.cancelShow(-1); 
    			result.put("message", "Stopped recording playback");
    		} else {
    			RecordingPlaybackShow tempShow = new RecordingPlaybackShow(controller, recording);
    			tempShow.setShowGroupId(0);
    			tempShow.setDescription("(recorded show)");
    			appConfig.startRecordingPlaybackShow(tempShow);
    			result.put("message", "Started recording playback");
    		}
    		
    	} else if (action.equals("clearLogs")) {
    		// startPollRequests();
    		appConfig.clearAppConfigExceptions();
    		controller.getAudioController().clearExceptions();
    		appConfig.clearAudioSourceExceptions();
    		appConfig.clearDmxDeviceExceptions();
    		appConfig.clearShowExceptions();
    		result.put("exceptions", Collections.EMPTY_LIST);
    		result.put("message", "Exceptions cleared");
    		result.put("logCount", 0L);
    		
    	} else if (action.equals("resetDMX")) {
			
    	} else {
    		
    		throw new IllegalArgumentException("Unknown action '" + action + "'");
    	}
    	
    	request.setAttribute("json", Struct.structuredMapToJson(result));
		return mapping.findForward(forward);
		
    }
    
    String getColorHexString(Color c) {
    	String r = Integer.toHexString(c.getRed());
    	String g = Integer.toHexString(c.getGreen());
    	String b = Integer.toHexString(c.getBlue());
    	return "#" + ((r.length()==1) ? "0" : "") + r +
    	  ((g.length()==1) ? "0" : "") + g +
    	  ((b.length()==1) ? "0" : "") + b;
    }
    
    Map getVersionData() throws IOException {
    	Map version = new HashMap();
	    InputStream is = FancyControllerAction.class.getClassLoader().getResourceAsStream("/build.properties");
    	Properties props = new Properties();
    	if (is==null) {
    		props.put("error", "Missing build.properties");
    	} else {
	    	props.load(is);
	    	is.close();
    	}
    	String v = (String) props.get("maven.pom.version");
    	if (v==null || v.equals("${pom.version}")) { v="(development release)"; }
    	version.put("release", v);
    	
    	v = (String) props.get("bamboo.buildNumber");
    	if (v==null || v.equals("${bambooBuildNumber}")) { v="N/A"; }
    	version.put("buildNumber", v);
    	String jarVersion = RXTXVersion.getVersion();
    	String dllVersion = "unknown";
    	try {
    		dllVersion = RXTXVersion.nativeGetVersion();
    	} catch (Error e1) {
    		try {
    			dllVersion = RXTXCommDriver.nativeGetVersion();
    		} catch (Exception e2) {
    			logger.error("Exception 1 determining version: ", e1);
    			logger.error("Exception 2 determining version: ", e2);
    			dllVersion = "Exception determining version: " + e1.getMessage();
    		}
    	}
    	version.put("rxtxJarVersion", jarVersion);
    	version.put("rxtxDllVersion", dllVersion);
    	return version;
    }
    
    public void addExceptions(List exceptions, String type, List<ExceptionContainer.TimestampedException> e1) {
		synchronized(e1) {
			for (int i=0; i<e1.size(); i++) {
				ExceptionContainer.TimestampedException te = e1.get(i);
				Map m = new HashMap();
				m.put("type", type);
				m.put("timestamp", te.getTimestamp());
				m.put("count", te.getCount());
				if (te.getCount()>1) { m.put("firstTimestamp", te.getFirstTimestamp()); }
				m.put("message", te.getException().getMessage());
				m.put("trace", ExceptionUtils.getStackTraceWithRevisions(te.getException(), 
					FancyControllerAction.class.getClassLoader(), ExceptionUtils.HIGHLIGHT_HTML, "com.randomnoun"));
				exceptions.add(m);
			}
		}
    }
    
    public void addShowExceptions(List exceptions, List<AppConfig.TimestampedShowException> e2) {
		synchronized(e2) {
			for (int i=0; i<e2.size(); i++) {
				TimestampedShowException te = e2.get(i);
				Map m = new HashMap();
				m.put("type", "show");
				m.put("timestamp", te.getTimestamp());
				m.put("count", te.getCount());
				if (te.getCount()>1) { m.put("firstTimestamp", te.getFirstTimestamp()); }
				m.put("showId", te.getShow().getId());
				m.put("message", te.getException().getMessage());
				m.put("trace", ExceptionUtils.getStackTraceWithRevisions(te.getException(), 
    					FancyControllerAction.class.getClassLoader(), ExceptionUtils.HIGHLIGHT_HTML, "com.randomnoun"));
				exceptions.add(m);
			}
		}
    }
    
    Double twoDigits(Double input) {
    	return new Double(Math.floor(input.doubleValue()*100)/100);
    }


    public List<Fixture> getFixtureList(Controller controller, String fixtureIds) {
    	List<Fixture> result = new ArrayList<Fixture>();
    	if (Text.isBlank(fixtureIds)) { return result; }
    	String[] fixtureIdStrings = fixtureIds.split(",");
		for (String fixtureId : fixtureIdStrings) {
			Fixture f = controller.getFixture(Integer.parseInt(fixtureId));
			result.add(f);
		}
		return result;
    }

    
}
