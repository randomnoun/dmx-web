package com.randomnoun.dmx.web.action;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.log4j.Logger;
import org.apache.struts.action.Action;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;
import org.springframework.jdbc.core.JdbcTemplate;

import com.randomnoun.common.ErrorList;
import com.randomnoun.common.Struct;
import com.randomnoun.common.security.User;
import com.randomnoun.dmx.audioController.AudioController;
import com.randomnoun.dmx.audioSource.AudioSource;
import com.randomnoun.dmx.config.AppConfig;
import com.randomnoun.dmx.dao.DeviceDAO;
import com.randomnoun.dmx.dmxDevice.DmxDevice;
import com.randomnoun.dmx.to.DeviceTO;
import com.randomnoun.dmx.web.Table;
import com.randomnoun.dmx.web.TableEditor;
import com.randomnoun.dmx.web.TableEditor.TableEditorResult;

/*
 * @XXX we should probably have startUniverseIdx and endUniverseIdx
 * @XXX also, only one active audiocontroller / audiosource. perhaps. who knows. 
 * 
 * values per device to handle devices that span multiple universes.
 *
 * NB: it should be OK to have multiple devices generating output
 * on the same universe number.
 * 
 */

/**
 * Device entry action.
 *
 * Forwards generated by this action:
 * <attributes>
 * success - displays entry page
 * </attributes>
 *
 * @version         $Id$
 * @author          knoxg
 */
public class MaintainDeviceAction
    extends Action {
    /** A revision marker to be used in exception stack traces. */
    public static final String _revision = "$Id$";

    /** Logger instance for this class */
    private static final Logger logger = Logger.getLogger(MaintainDeviceAction.class);

	public Map getParameterMap(HttpServletRequest request) {
		Map map = new HashMap();
		for (Enumeration e = request.getParameterNames(); e.hasMoreElements();) {
			String param = (String) e.nextElement();
			map.put(param, request.getParameter(param));
		}
		return map;
	}



    public static class DeviceTableEditor extends TableEditor {

    	private final static String[] fieldNames = 
    		new String[] { "id", "name", "className", "active", "universeNumber" };

    	private final static String[] fieldNames2 = 
    		new String[] { "id", "name", "className", "active", "universeNumber", "devicePropertyCount" };

    	String deviceType;
    	
    	public DeviceTableEditor(String deviceType) {
    		this.deviceType = deviceType;
    	}
    	
    	// @TODO this is all rather silly...
    	
    	@Override
		public void createRow(Map row) throws Exception {
    		AppConfig appConfig = AppConfig.getAppConfig();
    		JdbcTemplate jt = appConfig.getJdbcTemplate();
    		DeviceDAO deviceDAO = new DeviceDAO(jt);
    		DeviceTO device = new DeviceTO();
    		Struct.setFromMap(device, row, false, true, false, fieldNames);
    		device.setType(deviceType);
    		deviceDAO.createDevice(device);
		}

    	/** @TODO: the reason this is so awfully slow is that the update detection isn't working
    	 * (rows are being updated in the DB even though they haven't changed in the UI).
    	 * Also: batch updates ?
    	 */
		@Override
		public void updateRow(Map row) throws Exception {
			JdbcTemplate jt = AppConfig.getAppConfig().getJdbcTemplate();
    		DeviceDAO deviceDAO = new DeviceDAO(jt);
    		DeviceTO device = new DeviceTO();
    		Struct.setFromMap(device, row, false, true, false, fieldNames);
    		device.setType(deviceType);
    		deviceDAO.updateDevice(device);
		}

		@Override
		public void deleteRow(Map row) throws Exception {
			JdbcTemplate jt = AppConfig.getAppConfig().getJdbcTemplate();
    		DeviceDAO deviceDAO = new DeviceDAO(jt);
    		DeviceTO device = new DeviceTO();
    		Struct.setFromMap(device, row, false, true, false, fieldNames);
    		deviceDAO.deleteDevice(device);
		}

		private void init() {
    	}

    	public void removeEmptyRows(Map form) {
    		removeEmptyRows(form, fieldNames, "devices");
    	}
    	
    	/**
    	 * Validates information passed down from the presentation layer.  Checks for
    	 * mandatory and maximum length.
    	 *
    	 * @param row the row containing information for each stocked item to be maintained
    	 *
    	 * @return true if validation successful or false otherwise
    	 */
    	public boolean validateRow(Map row) {
    	    boolean valid = true;
    	    valid = valid & table.checkMandatory("className", 255, "Interface type"); // @TODO check against IDs in DB
    	    valid = valid & table.checkMandatory("name", 100, "Name");
    	    
    	    //valid = valid & table.checkMandatory("onCancelDeviceDefId", 10, "DMX offset");
    	    //valid = valid & table.checkNumeric("onCancelDeviceId", "On cancel goto");
    	    //valid = valid & table.checkNumeric("onCompleteDeviceId", "On complete goto");
    	    //valid = valid & table.checkNumeric("deviceGroupId", "Device group");
    	    return valid;
    	}
    	  
    	  
    	public TableEditorResult maintainDevices(Map request) {
    		TableEditorResult result;
		    List updateErrors;
		    
		    table = new Table(request, "devices", "id", String.class);
		    table.setEditableKey(false);
		    init();

		    // table validation and maintenance
    		if (!validateTable() || !maintainTable()) {
		        // updates failed
    			result = getResult();
    			result.setRows(getTable().getRows());
    			result.setErrors(getTable().getErrors());
    		} else {
    			result = getResult();
    			result.setRows(getDevices());
    			ErrorList errors = getTable().getErrors();
    			errors.addError("Devices updated", "Table has been updated", ErrorList.SEVERITY_OK);
    			result.setErrors(errors);

    			long startTime = System.currentTimeMillis();
	    		AppConfig.getAppConfig().reloadDevicesFixturesAndShows(true);
	    		logger.info("device reload time=" + ((System.currentTimeMillis() - startTime)/1000.0) + " sec");
    		}
    		return result;
    	}
    	
    	public boolean validateTable() {
    		boolean valid = super.validateTable();
    		if (!valid) { return false; }
    		
    		// @XXX: further validation to do:
    		// check that all active universes are sequentially numbered from 1
    		// (or possibly put in nulldevices for empty universes?)
    		return true;
    	}
    	
    	public Map readDevices(Map request) {
			Map form = new HashMap();
			List devices = getDevices();
			form.put("devices", devices);
			form.put("devices_size", devices.size());
			//form.put("deviceDefs", getDeviceDefs());
			//form.put("followupDevices", getFollowupDevices());
			//form.put("deviceGroups", getDeviceGroups());
			form.put("classNames", getDeviceClassNames());
			return form;
    	}
    	
    	public List getDevices() {
    		AppConfig appConfig = AppConfig.getAppConfig();
    		JdbcTemplate jt = appConfig.getJdbcTemplate();
    		DeviceDAO deviceDAO = new DeviceDAO(jt);
    		List<DeviceTO> devices = deviceDAO.getDevicesWithPropertyCounts("type='" + deviceType + "'");
    		// holy freaking christ. This is 12 types of wrong. Or 1:02AM types of wrong. Take your pick.
    		List devicesAsMaps = new ArrayList();
    		for (DeviceTO device : devices) {
    			Map deviceMap = new HashMap();
    			Struct.setFromObject(deviceMap, device, false, true, true, fieldNames2);
    			devicesAsMaps.add(deviceMap);
    		}
    		return devicesAsMaps;
    	}
    	
    	// D=DMX, S=audioSource, C=audioController
    	
    	public List getDeviceClassNames() {
    		AppConfig appConfig = AppConfig.getAppConfig();
    		List deviceClassNames = null;
    		Class deviceSuperClass = null;
    		if (deviceType.equals("D")) {
    			deviceSuperClass = DmxDevice.class;
    			deviceClassNames = (List) appConfig.get("dmxDeviceClassNames");
    		} else if (deviceType.equals("C")) {
    			deviceSuperClass = AudioController.class;
    			deviceClassNames = (List) appConfig.get("audioControllerClassNames");    			
    		} else if (deviceType.equals("S")) {
    			deviceSuperClass = AudioSource.class;
    			deviceClassNames = (List) appConfig.get("audioSourceClassNames");
    		} else {
    			throw new IllegalArgumentException("illegal deviceType '" + deviceType + "'; expected 'D', 'S' or 'C'.");
    		}
    		
    		for (int i=0; i<deviceClassNames.size(); i++) {
    			Map deviceMap = (Map) deviceClassNames.get(i);
    			String deviceClassName = (String) deviceMap.get("id");
    			String deviceName = deviceClassName;
    			try {
    				Class clazz = Class.forName(deviceClassName);
    				Constructor con = clazz.getConstructor(Map.class);
    				Object deviceObj = con.newInstance(new Object[] { null });
    				if (!deviceSuperClass.isAssignableFrom(clazz)) {
    					throw new IllegalStateException("device type '" + deviceSuperClass.getName() + "' is not assignable from device '" + deviceClassName + "'");
    				}
    				Method getNameMethod = clazz.getMethod("getName", new Class[] {}); 
    				deviceName = (String) getNameMethod.invoke(deviceObj);
    			} catch (Exception e) {
    				logger.error("Could not determine name of device '" + deviceClassName + "'", e);
    			}
    			deviceMap.put("name", deviceName);
    			
    		}
    		return deviceClassNames;
    	}
    	
   }
      
      
    
    /**
     * Perform this struts action. See the javadoc for this
     * class for more details.
     *
     * @param mapping The struts ActionMapping that triggered this Action
     * @param actionForm An ActionForm (if available) holding user input for this Action
     * @param request The HttpServletRequest for this action
     * @param response The HttpServletResponse for this action
     *
     * @return An ActionForward representing the result to return to the end-user
     *
     * @throws Exception If an exception occurred during action processing
     */
    @SuppressWarnings({ "unchecked", "rawtypes" })
	public ActionForward execute(ActionMapping mapping, ActionForm actionForm, HttpServletRequest request, HttpServletResponse response)
        throws Exception 
    {
		HttpSession session = request.getSession();
		User user = (User) session.getAttribute("user");
		AppConfig appConfig = AppConfig.getAppConfig();
		String forward = "success";
		JdbcTemplate jt = appConfig.getJdbcTemplate();
		String deviceType = request.getParameter("deviceType");
		String action = request.getParameter("action");
		
		if (!("D".equals(deviceType) || "C".equals(deviceType) || "S".equals(deviceType))) {
			throw new IllegalArgumentException("Unknown deviceType '" + deviceType + "'; expected 'D', 'C' or 'S'");
		}
		
		if (action==null) { action = ""; }
		if (action.equals("")) {
			// default action displays entry page
			DeviceTableEditor tableEditor = new DeviceTableEditor(deviceType);
			request.setAttribute("form", tableEditor.readDevices(null));
			
		} else if (action.equals("maintain") || action.equals("editProperties")) {
			Map form = new HashMap();
			Struct.setFromRequest(form, request);
			
			//System.out.println(Struct.structuredMapToString("form", form));
			DeviceTableEditor tableEditor = new DeviceTableEditor(deviceType);
			tableEditor.removeEmptyRows(form);
			TableEditorResult result = tableEditor.maintainDevices(form);
			//System.out.println("======================================");
			//System.out.println(Struct.structuredListToString("rows", result.getRows()));
			//System.out.println(Struct.structuredListToString("errors", result.getErrors()));
			form.put("devices", result.getRows());
			form.put("devices_size", result.getRows().size());
			form.put("classNames", tableEditor.getDeviceClassNames());
			//form.put("deviceDefs", tableEditor.getDeviceDefs());
			//form.put("followupDevices", tableEditor.getFollowupDevices());
			//form.put("deviceGroups", tableEditor.getDeviceGroups());
			request.setAttribute("errors", result.getErrors());
			request.setAttribute("form", form);
			
			if (!result.getErrors().hasErrors(ErrorList.SEVERITY_INVALID) && action.equals("editProperties")) {
				forward = "deviceProperties";
			}
			
		} else {
			throw new IllegalArgumentException("Invalid action '" + action + "'");
		}

		request.setAttribute("deviceType", deviceType);
        return mapping.findForward(forward);
    }
    
}
